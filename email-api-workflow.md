# Backend API: Send Quote Notification Email Workflow

This document outlines the backend process when a request is made to send a quote notification email, typically triggered by the frontend after a quote has been successfully generated.

## API Endpoint: `POST /api/v1/email/send`

### 1. Request Data from Frontend

The backend expects a JSON object in the request body with the following structure for quote-related emails:

```json
{
  "to": "customer@example.com", // The recipient's email address
  "type": "quote",              // Specifies that a quote email should be sent
  "data": { /* ... */ }         // The full quote object
}
```
-   `to`: (String) The email address of the customer who generated the quote.
-   `type`: (String) Must be `"quote"` for this workflow.
-   `data`: (Object) This is the complete `quote` object that the frontend received as a response from the `POST /api/v1/quotes` endpoint. It contains all quote details, including `quoteNumber`, `totalPremium`, and potentially nested objects like `policyHolder` (which might have `firstName`).

### 2. Backend Processing in `email.routes.ts`

1.  **Receive Request:** The Express.js router directs the `POST /api/v1/email/send` request to its handler function.

2.  **Destructure Request Body:**
    *   `const { to, type = 'quote', data } = req.body;`
    *   The `type` defaults to `'quote'` if not explicitly provided, though the frontend is expected to send it.

3.  **Initial Validation:**
    *   `if (!to || !data)`: The system checks if the recipient email (`to`) or the `data` object (containing quote details) is missing.
    *   If either is missing, a `400 Bad Request` response is sent immediately:
        ```json
        { "error": "Missing recipient or data." }
        ```

4.  **Email Type Routing:**
    *   The code checks the `type` field to determine which email sending logic to invoke.
    *   `if (type === 'quote')`:
        *   `await sendQuoteEmail(to, data);`: The request is passed to the `sendQuoteEmail` function, which is imported from `email.service.ts`. This function handles the specifics of preparing and sending the quote notification.
    *   `else if (type === 'policy')`:
        *   This branch handles sending policy-related emails and is not part of the quote notification workflow.
    *   `else`:
        *   If the `type` is neither `'quote'` nor `'policy'`, it's considered invalid.
        *   A `400 Bad Request` response is sent:
            ```json
            { "error": "Invalid email type specified." }
            ```

### 3. `sendQuoteEmail` Function in `email.service.ts`

This asynchronous function is responsible for constructing and dispatching the actual email.

1.  **Function Signature:**
    *   `async function sendQuoteEmail(to: string, data: any)`

2.  **Generate Email Content:**
    *   `const template = quoteEmailTemplate({ ... });`
    *   The `quoteEmailTemplate` function (located in `../utils/emailTemplates.ts`) is invoked. This function is responsible for generating the email's subject and HTML body.
    *   It receives an object containing specific details extracted from the `data` (the full quote object):
        *   `quoteNumber: data.quoteNumber`
        *   `firstName: data.policyHolder?.firstName || 'Customer'`: It attempts to use the first name of the policyholder from the quote data. If `data.policyHolder` or `data.policyHolder.firstName` is not available, it defaults to the generic term "Customer".
        *   `totalPremium: data.totalPremium`
    *   The `quoteEmailTemplate` returns an object, for example:
        ```javascript
        {
          subject: `Your Event Insurance Quote - ${data.quoteNumber}`,
          html: `<p>Dear ${firstName},</p><p>Thank you for generating a quote...</p>` // (Simplified example)
        }
        ```

3.  **Dispatch Email using `nodemailer`:**
    *   `await transporter.sendMail({ mailOptions });`
    *   `transporter`: This is a pre-configured `nodemailer` transport object. It's typically initialized once when the application starts (or when `email.service.ts` is loaded) using `nodemailer.createTransport(...)`. The transport is configured with SMTP server details (e.g., service like Gmail, host, port, secure, auth credentials) usually read from environment variables (e.g., `process.env.SMTP_SERVICE`, `process.env.SMTP_EMAIL`, `process.env.SMTP_PASS`).
    *   **Mail Options Object:**
        *   `from: process.env.SMTP_EMAIL`: The sender's email address, configured via an environment variable.
        *   `to: to`: The customer's email address, passed as an argument to `sendQuoteEmail`.
        *   `subject: template.subject`: The subject line generated by `quoteEmailTemplate`.
        *   `html: template.html`: The HTML content for the email body generated by `quoteEmailTemplate`.
        *   No attachments are specified for this particular quote notification email.

### 4. Response to Frontend (from `email.routes.ts`)

*   If the `sendQuoteEmail` function (and thus `transporter.sendMail`) completes successfully without throwing an error:
    *   The route handler sends a `200 OK` success response:
        ```json
        {
          "success": true,
          "message": "Email sent successfully."
        }
        ```

### 5. Error Handling

*   **Within `email.routes.ts` (Route Handler):**
    *   A `try...catch` block surrounds the call to `sendQuoteEmail`.
    *   If any error is thrown during the email sending process (either from `sendQuoteEmail` itself, or from `nodemailer` if it fails to send the email):
        *   The error is logged to the console: `console.error('Email send error:', error);`
        *   An error message is determined: `const errorMessage = error instanceof Error ? error.message : 'Failed to send email.';`
        *   A `500 Internal Server Error` response is sent to the frontend:
            ```json
            { "error": "Specific error message or 'Failed to send email.'" }
            ```
*   **Within `email.service.ts` (`sendQuoteEmail`):**
    *   If `transporter.sendMail` encounters an issue (e.g., invalid SMTP credentials, SMTP server unavailable, recipient address rejected by the server), it will throw an error.
    *   This error propagates up and is caught by the `try...catch` block in the route handler in `email.routes.ts`, as described above.

This workflow ensures that the request to send an email is validated, the correct email content is generated based on the quote data, and the email is dispatched using a configured email transport. The frontend is then informed of the success or failure of this operation.
