# Backend API: Quote Creation Workflow

This document outlines the backend process when a quote is created via the `POST /api/v1/quotes` API endpoint, typically initiated by a customer from the frontend quote generator.

## API Endpoint: `POST /api/v1/quotes`

### 1. Request Data from Frontend

The backend expects a JSON object in the request body. This object contains all the information gathered from the user on the quote generation form.

**Example Request Payload:**
```json
{
  "residentState": "CA",
  "eventType": "wedding",
  "maxGuests": "100-150",
  "eventDate": "YYYY-MM-DD",
  "email": "customer@example.com",
  "coverageLevel": 10000,
  "liabilityCoverage": "1m/2m",
  "liquorLiability": true,
  "covidDisclosure": true,
  "specialActivities": false,
  "honoree1FirstName": "",
  "honoree1LastName": "",
  "honoree2FirstName": "",
  "honoree2LastName": "",
  "venueName": "",
  "venueAddress1": "",
  // ... other optional venue fields
  "firstName": "", // Policyholder details (can be empty at this stage)
  "lastName": "",  // Policyholder details (can be empty at this stage)
  // ... other optional policyholder fields
  "totalPremium": 150.00, // Calculated on frontend
  "basePremium": 100.00,  // Calculated on frontend
  "liabilityPremium": 50.00, // Calculated on frontend
  "liquorLiabilityPremium": 0.00, // Calculated on frontend
  "source": "CUSTOMER" // Indicates the origin of the quote
}
```
**Note:** The premium fields (`totalPremium`, `basePremium`, `liabilityPremium`, `liquorLiabilityPremium`) are pre-calculated on the frontend (within `QuoteContext` using constants from `utils/constants.ts`) and sent to the backend.

### 2. Backend Processing Steps

Upon receiving the request, the backend performs the following operations:

1.  **Receive Request:** The Express.js router directs the `POST /api/v1/quotes` request to the appropriate handler function.

2.  **Determine Source:**
    *   The code extracts `source` and `paymentStatus` from the request body (`fields`).
    *   It checks the `referer` header.
    *   `isAdminRequest` is determined: `true` if `source` is `'ADMIN'` or the `referer` URL path includes `/admin/`.
    *   `effectiveSource` is set. For a standard customer-generated quote, this will be `QuoteSource.CUSTOMER`.

3.  **Email Validation:**
    *   `if (!fields.email)`: If the `email` field is missing from the request, the server responds with a `400 Bad Request` error.

4.  **User Handling (using TypeORM):**
    *   The `User` repository is obtained from `AppDataSource`.
    *   `let user = await userRepository.findOneBy({ email: fields.email });`: The system attempts to find an existing user by the provided email address.
    *   **If User Does Not Exist:**
        *   `user = userRepository.create({ email: fields.email, firstName: fields.firstName || '', lastName: fields.lastName || '', phone: fields.phone || '' });`: A new `User` entity is created using the email and, if provided, first name, last name, and phone number.
        *   `await userRepository.save(user);`: The new user record is persisted to the database.

5.  **Prepare Quote Data:**
    *   An object `quoteData` is assembled from `fields` in the request body, containing data directly relevant to the `Quote` entity (e.g., `residentState`, `email`, `coverageLevel`, all premium values).

6.  **Create Quote Entity (TypeORM):**
    *   The `Quote` repository is obtained.
    *   `const newQuote = quoteRepository.create({ ... });`: A new `Quote` entity is instantiated with the following properties:
        *   `...quoteData`: Spreads the prepared data into the new quote.
        *   `quoteNumber: generateQuoteNumber()`: A unique quote number (e.g., `QN12345678`) is generated by a utility function.
        *   `status: isAdminRequest ? StepStatus.COMPLETE : StepStatus.STEP1;`: For customer-generated quotes, the status is set to `StepStatus.STEP1`, indicating the initial step of the quote process is complete.
        *   `source: effectiveSource;`: Set to `QuoteSource.CUSTOMER`.
        *   `isCustomerGenerated: effectiveSource === QuoteSource.CUSTOMER;`: Set to `true`.
        *   `user: user;`: The existing or newly created `User` entity is associated with this quote.

7.  **Create Event Entity (Conditional, TypeORM):**
    *   `if (fields.eventType && fields.eventDate && fields.maxGuests)`: This block executes only if essential event details (`eventType`, `eventDate`, `maxGuests`) are present in the request.
        *   `eventData`: An object is created containing event-specific fields from the request.
        *   The `Event` repository is obtained.
        *   `const newEvent = eventRepository.create(eventData);`: A new `Event` entity is created.
        *   **Create Venue Entity (Conditional, Nested within Event):**
            *   `if (fields.venueName)`: If a `venueName` is provided:
                *   `venueData`: An object is created for venue details.
                *   The `Venue` repository is obtained.
                *   `newEvent.venue = venueRepository.create(venueData);`: A new `Venue` entity is created and associated with the `newEvent`.
        *   `newQuote.event = newEvent;`: The newly created `Event` entity (potentially including its associated `Venue`) is linked to the `newQuote`.

8.  **Create PolicyHolder Entity (Conditional, TypeORM):**
    *   `if (fields.firstName && fields.lastName)`: This block executes if the policyholder's `firstName` and `lastName` are provided (these might be empty in the initial quote calculation step).
        *   `policyHolderData`: An object is created containing policyholder-specific fields.
        *   The `PolicyHolder` repository is obtained.
        *   `newQuote.policyHolder = policyHolderRepository.create(policyHolderData);`: A new `PolicyHolder` entity is created and linked to the `newQuote`.

9.  **Persist to Database:**
    *   `const savedQuote = await quoteRepository.save(newQuote);`: The `newQuote` entity, along with any newly created and associated entities (User, Event, Venue, PolicyHolder), is saved to the database. TypeORM handles the cascading saves, typically within a database transaction if configured at a higher level (e.g., in a service layer or middleware).

10. **Auto-Conversion Logic Check (Skipped in this flow):**
    *   `if (savedQuote.source === QuoteSource.CUSTOMER && paymentStatus === 'SUCCESS')`: This condition checks if the quote is customer-generated AND if a `paymentStatus` of `'SUCCESS'` was part of the request.
    *   For the standard "Calculate Quote" flow described here, `paymentStatus` is undefined or not `'SUCCESS'`. Therefore, this block of code, which handles automatic conversion of a quote to a policy after successful payment (part of a "Buy Now" or similar workflow), is **not executed**.

### 3. Response to Frontend

If the entire process is successful and the auto-conversion logic is not triggered:

*   **Status Code:** `201 Created`
*   **Response Body (JSON):**
    ```json
    {
      "message": "Quote saved successfully",
      "quoteNumber": "QN12345678", // The generated quote number
      "quote": { /* ... complete saved quote object ... */ }
    }
    ```
    The `quote` object in the response includes the database ID of the quote and all associated entities that were created (user, event, venue, policyholder).

### 4. Error Handling

*   **General Errors:** If any unexpected error occurs during the process:
    *   The error is logged to the console: `console.error('POST /api/v1/quotes error:', error);`
    *   A generic error message is prepared: `const message = error instanceof Error ? error.message : 'Server error';`
    *   The server responds with a `500 Internal Server Error`:
        ```json
        {
          "error": "Relevant error message or 'Server error'"
        }
        ```
*   **Oracle Unique Constraint Error:**
    *   There's a specific check for Oracle unique constraint violations (e.g., `ORA-00001`), which might occur if trying to insert a record that violates a unique key (though `generateQuoteNumber` aims to prevent this for `quoteNumber`).
    *   If detected, the server responds with a `409 Conflict`:
        ```json
        {
          "error": "A record with the provided information already exists. Please check the details and try again."
        }
        ```

This backend workflow ensures that quote data is validated, associated with a user, and persisted in the database along with related event and policyholder information if provided. The generated `quoteNumber` is then returned to the frontend, which stores it in local storage for subsequent steps or retrieval.
